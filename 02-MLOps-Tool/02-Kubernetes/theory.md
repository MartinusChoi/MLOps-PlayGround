# Kubernetes 란?

## 개념

> Container화된 애플리케이션의 배포/확장/운영을 자동화하기 위한 오픈 소스 시스템
> 
- 구글에 의해 개발
- CNCF(Cloud Native Computing Foundation)에 기여

## 주요 특징

### 자동화된 롤아웃 및 롤백

- 애플리케이션 업데이트 시 롤아웃을 자동 관리
- 문제 발생 시 이전 버전으로 롤백

### 서비스 발견 및 로드 밸런싱

- 서비스를 사용해 클러스터 내의 애플리케이션 쉽게 접근
- 트래픽을 자동 분산

### 스케일링

- 애플리케이션의 리소스 사용에 따라 자동/수동 스케일링

### 자체 치유

- 실패한 Container 재시작
- 건강하지 않은 Container 교체
- 준비되지 않은 노드로부터 애플리케이션 이전

## Kubernetes 작동 방식

---

### 클러스터 구성

- 먼저 쿠버네티스 클러스터를 구성
- 이 클러스터는 여러 노드(물리적 또는 가상 머신)와 이들을 관리하는 마스터 노드로 구성

### API 서버와의 통신

- 사용자 → kubectl 명령줄 인터페이스 혹은 API를 통해 API 서버와 통신
- 이를 통해 파드 생성, 업데이트, 삭제 등 작업 요청

### 스케줄링과 실행

- 스케줄러는 새로운 파드에 대해 가장 적합한 노드 선택
- kubelet → 해당 노드에서 파드의 컨테이너가 올바르게 실행되도록 관리

### 서비스 관리

- kube-proxy → 서비스를 통한 네트워크 트래픽 관리
- 서비스 → 파드 그룹에 안정적인 접근점을 제공

### 자동화된 롤아웃 및 롤백

- Deployment를 통해 애플리케이션의 업데이트, 롤아웃 및 롤백 자동 관리

### 스케일링과 자체 치유

- 클러스터
    
    → 애플리케이션의 수요에 따라 자동으로 스케일링
    
    → 실패한 파드 재시작하는 등 자체 치유 기능 제공
    

# Kubernetes 클러스터 아키텍처

## Kubernetes 아키텍처

> Master-Node 구조로 이루어진 클러스터를 사용함

## 마스터 컴포넌트

### API 서버 (Kube-apiserver)

- 쿠버네티스 API를 제공
- 사용자와 내부 컴포넌트 간의 중재자 역할

### 스케쥴러 (kube-scheduler)

- 새로 생성된 파드(하나 이상의 Container)를 어떤 노드로 할당할 지 결정

### 컨트롤러 매니저 (kube-controller-manager)

- 여러 컨트롤러를 실행

### etcd

- 모든 클러스터 데이터를 저장하는 경량의 분산 key-value 저장소

## 노드 컴포넌트

### kubelet

- 각 노드에서 실행
- 파드 스펙(Spec)에 설명된 대로 컨테이너가 실행되고 있는지 확인

### kube-proxy

- 각 노드의 네트워크 규칙 관리

### 컨테이너 런타임

- 컨테이너 실행을 담당하는 소프트웨어
- ex) Docker containerd, CRI-O 등

# Kubernetes 주요 구성 요소

## 구성 요소

- Pod
- Service
- Deployment
- ReplicaSet
- NameSpace

## Pod

> 쿠버네티스에서 배포할 수 있는 가장 작은 작업 단위
→ 하나 이상으 Container 포함 가능
→ 이들은 스토리지와 네트워크를 공유함
> 

### 주요 특징

- 컨테이너 그룹핑
    - 하나 이사의 밀접하게 관련된 컨테이너를 그룹화
    - 이 컨테이너 들은 같은 컴퓨팅 리소르를 공유함
- 공유 리소스
    - 파드 내의 컨테이너는 같은 IP 주소와 포트 공간 공유
    - 서로 localhost를 통해 통신
- 일시적인 성격
    - 파드는 일시적임
    - 파드가 삭제되면 그 안의 컨테이너도 함께 삭제됨
    - 이는 파드가 불변적이지 않고 변경 가능한 리소스로 간주됨을 의미
- 생명 주기
    - 생성/실행/종료 까지의 생명주기를 가짐
    - 파드가 종료되면, 쿠버네티스 클러스터에서 제거됨

### 사용 예시

- 단인 컨테이너 파드 : 대부분의 파드는 하나의 컨테이너 만을 실행
- 멀티 컨테이너 파드 : 로깅, 데이터 백업, 데이터 처리와 같은 보조 기능을 수행하는 사이드카(Sidecar) 컨테이너 포함

### 왜 Docker Container를 직접 관리안하고 Pod라는 관리 단위를 만들었지?

→ Docker 기반이 아닌 다른 기술 기반의 Container를 관리해야할 수 있기 때문에 확장성을 위해서 Pod라는 관리 계층을 만들었다고 이해할 수 있음

## Service

> 파드 집합에 대한 안정적인 네트워크 주소 제공
→ 서비스를 통해 파드 집합에 대한 접근 관리
→ 로드 밸런싱 및 서비스 발견 가능
> 

### 주요 특징

- 안정적인 주소 제공
    - 파드 집합에 지속적으로 접근할 수 있는 안정적인 IP 주소와 포트 제공
- 로드 밸런싱
    - 서비스는 요청을 여러 파드에 분산 시켜 로드 밸런싱 수행
- 서비스 발견
    - DNS 또는 환경 변수를 통해 클러스터 내의 다른 파드가 서비스를 쉽게 찾을 수 있음
- 서비스 타입
    - 다양한 서비스 타입을 통해 다양한 네트워크 요구 사항 충족
        - ClusterIP
        - NodePort
        - LoadBalancer
        - ExternalName

### 사용 예시

- ClusterIP : 클러스터 내부에서만 접근 가능한 서비스를 만들 때 사용
- LoadBalancer : 클라우드 제공 업체의 로드 밸런서를 사용하여 서비스에 대한 외부 접근 관리

## Deployment

> 쿠버네티스에서 파드와 레플리카셋의 상태를 선언적으로 관리하는 API 오브젝트 (사용자가 정의한 대로 Pod와 ReplicaSet의 수/상태를 유지하는 방식을 의미함)
→ 애플리케이션의 배포, 업데이트, 스케일링 등을 자동화/관리
> 

### 주요 특징

- 자동화된 롤아웃과 롤백
    - 애플리케이션의 새 버전 롤아웃, 필요한 경우 이전 버전으로 롤백 자동화
- 상태 관리
    - 원하는 상태 (Desired State)를 정의
    - 쿠버네티스가 실제 상태(Current State)를 그 상태로 유지
- 선언적 업데이트
    - YAML파일이나 JSON 형식을 사용해 애플리케이션을 업데이트하는 방식을 선언
- 스케일링
    - 파드의 수를 수동/자동으로 조절
    - 애플리케이션을 스케일링

### 사용 예시

- 새 버전 배포 : 데플로이먼트를 사용해 애플리케이션의 새 버전 롤아웃
- 스케일링 : `kubectl scale deployment` 명령어를 사용해 데플로이먼트를 확장하거나 축소

## ReplicaSet

> 파드의 복제본을 유지 관리하는 쿠버네티스 오브젝트
→ 파드의 원하는 복제본 수를 지정, 지정된 수의 파드 복제본이 항상 실행되고 있도록 보장
> 

### 주요 특징

- 복제본 수 관리 : 지정된 수의 파드 복제본을 유지
- 자체 치유 : 실패한 파드를 자동으로 대체하여 복제본 수 유지
- 유연한 파드 선택 : 레이블 선택기 (Label Selector)를 사용해 관리할 파드 결정

### 사용 예시

- 애플리케이션 가용성 보장 : 애플리케이션의 가용성 높이기 위해 여러 파드의 복제본을 실행
- 부하 분산 : 여러 파드 복제본을 통해 트래픽 분산 → 애플리케이션에 대한 부하가 각 복제본에 균등하게 분배